-- Inicialização do banco de dados para o sistema de créditos
-- Este script é executado automaticamente quando o container PostgreSQL é iniciado

-- Criação da extensão para UUID (se necessário)
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Criação da tabela de créditos
CREATE TABLE IF NOT EXISTS credito (
                                       id BIGINT GENERATED BY DEFAULT AS IDENTITY,
                                       numero_credito VARCHAR(50) NOT NULL UNIQUE,
    numero_nfse VARCHAR(50) NOT NULL,
    data_constituicao DATE NOT NULL,
    valor_issqn DECIMAL(15, 2) NOT NULL,
    tipo_credito VARCHAR(50) NOT NULL,
    simples_nacional BOOLEAN NOT NULL DEFAULT FALSE,
    aliquota DECIMAL(5, 2) NOT NULL,
    valor_faturado DECIMAL(15, 2) NOT NULL,
    valor_deducao DECIMAL(15, 2) NOT NULL,
    base_calculo DECIMAL(15, 2) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id)
    );

-- Índices para otimização de consultas
CREATE INDEX IF NOT EXISTS idx_credito_numero_nfse ON credito(numero_nfse);
CREATE INDEX IF NOT EXISTS idx_credito_numero_credito ON credito(numero_credito);
CREATE INDEX IF NOT EXISTS idx_credito_data_constituicao ON credito(data_constituicao);
CREATE INDEX IF NOT EXISTS idx_credito_tipo_credito ON credito(tipo_credito);

-- Criação da tabela de auditoria (corrigida)
CREATE TABLE IF NOT EXISTS credito_auditoria (
                                                 id BIGINT GENERATED BY DEFAULT AS IDENTITY,
                                                 credito_id BIGINT,
                                                 operacao VARCHAR(20) NOT NULL, -- INSERT, UPDATE, DELETE
    dados_antigos JSONB,
    dados_novos JSONB,
    usuario VARCHAR(100),
    data_operacao TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    CONSTRAINT fk_credito_auditoria_credito FOREIGN KEY (credito_id) REFERENCES credito(id) ON DELETE SET NULL
    );

-- Índice para auditoria
CREATE INDEX IF NOT EXISTS idx_auditoria_credito_id ON credito_auditoria(credito_id);
CREATE INDEX IF NOT EXISTS idx_auditoria_data_operacao ON credito_auditoria(data_operacao);

-- Função para atualizar timestamp automaticamente
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
RETURN NEW;
END;
$$ language 'plpgsql';

-- Trigger para atualizar updated_at automaticamente
DROP TRIGGER IF EXISTS update_credito_updated_at ON credito;
CREATE TRIGGER update_credito_updated_at
    BEFORE UPDATE ON credito
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Função para auditoria (corrigida)
CREATE OR REPLACE FUNCTION credito_audit_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'DELETE' THEN
        INSERT INTO credito_auditoria (credito_id, operacao, dados_antigos, usuario)
        VALUES (OLD.id, 'DELETE', row_to_json(OLD), current_user);
RETURN OLD;
ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO credito_auditoria (credito_id, operacao, dados_antigos, dados_novos, usuario)
        VALUES (NEW.id, 'UPDATE', row_to_json(OLD), row_to_json(NEW), current_user);
RETURN NEW;
ELSIF TG_OP = 'INSERT' THEN
        INSERT INTO credito_auditoria (credito_id, operacao, dados_novos, usuario)
        VALUES (NEW.id, 'INSERT', row_to_json(NEW), current_user);
RETURN NEW;
END IF;
RETURN NULL;
END;
$$ language 'plpgsql';

-- Inserção de dados de teste (ANTES do trigger de auditoria)
INSERT INTO credito (
    numero_credito,
    numero_nfse,
    data_constituicao,
    valor_issqn,
    tipo_credito,
    simples_nacional,
    aliquota,
    valor_faturado,
    valor_deducao,
    base_calculo
) VALUES
      ('123456', '7891011', '2024-02-25', 1500.75, 'ISSQN', true, 5.0, 30000.00, 5000.00, 25000.00),
      ('789012', '7891011', '2024-02-26', 1200.50, 'ISSQN', false, 4.5, 25000.00, 4000.00, 21000.00),
      ('654321', '1122334', '2024-01-15', 800.50, 'Outros', true, 3.5, 20000.00, 3000.00, 17000.00),
      ('111222', '5566778', '2024-03-10', 2250.00, 'ISSQN', false, 6.0, 37500.00, 2500.00, 35000.00),
      ('333444', '9900112', '2024-03-15', 1875.25, 'ISSQN', true, 4.0, 46881.25, 1881.25, 45000.00),
      ('555666', '1122334', '2024-02-28', 675.00, 'Outros', false, 3.0, 22500.00, 1500.00, 21000.00),
      ('777888', '3344556', '2024-04-05', 3150.00, 'ISSQN', true, 7.0, 45000.00, 0.00, 45000.00),
      ('999000', '7788990', '2024-04-12', 1440.00, 'Outros', false, 4.8, 30000.00, 3000.00, 27000.00)
    ON CONFLICT (numero_credito) DO NOTHING;

-- Trigger para auditoria (DEPOIS dos dados de teste)
DROP TRIGGER IF EXISTS credito_audit ON credito;
CREATE TRIGGER credito_audit
    AFTER INSERT OR UPDATE OR DELETE ON credito
    FOR EACH ROW
    EXECUTE FUNCTION credito_audit_trigger();

-- Criação de usuário específico para a aplicação (opcional)
DO $$
BEGIN
    IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'app_user') THEN
CREATE ROLE app_user WITH LOGIN PASSWORD 'app_pass123';
END IF;
END
$$;

-- Concessão de permissões
GRANT CONNECT ON DATABASE creditos_db TO app_user;
GRANT USAGE ON SCHEMA public TO app_user;
GRANT SELECT, INSERT, UPDATE, DELETE ON credito TO app_user;
GRANT SELECT, INSERT ON credito_auditoria TO app_user;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO app_user;

-- Visualização para relatórios
CREATE OR REPLACE VIEW vw_creditos_resumo AS
SELECT
    numero_nfse,
    COUNT(*) as total_creditos,
    SUM(valor_issqn) as total_issqn,
    AVG(aliquota) as aliquota_media,
    SUM(valor_faturado) as total_faturado,
    MIN(data_constituicao) as primeira_constituicao,
    MAX(data_constituicao) as ultima_constituicao
FROM credito
GROUP BY numero_nfse;

-- Concessão de permissão na view
GRANT SELECT ON vw_creditos_resumo TO app_user;

-- Comentários nas tabelas
COMMENT ON TABLE credito IS 'Tabela principal para armazenar informações de créditos constituídos';
COMMENT ON TABLE credito_auditoria IS 'Tabela de auditoria para rastrear alterações nos créditos';
COMMENT ON VIEW vw_creditos_resumo IS 'Visão resumida dos créditos agrupados por NFS-e';

-- Informações sobre a inicialização
SELECT 'Banco de dados inicializado com sucesso!' as status,
       (SELECT COUNT(*) FROM credito) as total_creditos_inseridos,
       CURRENT_TIMESTAMP as data_inicializacao;